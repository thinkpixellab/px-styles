////
/// @group Collections
////

@use 'json.scss' as *;
@use 'strings.scss' as *;
@use 'units.scss' as *;

/// Get a value from a map if the key exists, otherwise return a fallback
///
/// @example map-get-default((a:1, b:2), a, 3) => 1
/// @example map-get-default((a:1, b:2), wontwork, 3) => 3

@function map-get-default($map, $key, $default) {
    @if (map-has-key($map, $key)) {
        @return map-get($map, $key);
    } @else {
        @return $default;
    }
}

/// Deep lookup for map values, each parameter represents the next level lookup
/// @param {map} $map - Map
/// @param {arglist} $keys - Key chain

@function map-deep-get($map, $keys...) {
    @each $key in $keys {
        $map: map-get($map, $key);
    }
    @return $map;
}

// /// Get just the keys from a map (similar to JavaScript's Object.keys)
// /// @param {*} $map

// @function map-keys($map) {
//     $keys: ();
//     @each $key, $val in $map {
//         $keys: append($keys, $key);
//     }
//     @return $keys;
// }

// /// Get just the keys from a map (similar to JavaScript's Object.values)
// /// @param {*} $map

// @function map-values($map) {
//     $vals: ();
//     @each $key, $val in $map {
//         $vals: append($vals, $val);
//     }
//     @return $vals;
// }

/// If $list-or-val is a list, return the nth value; if the item is a value
/// return the value; if the value is null return the default
///
/// @example nth-or-val((a, b, c), 1, d) => 1
/// @example nth-or-val(a, 1, d) => a
/// @example nth-or-val(null, 1, d) => d

@function nth-or-val($list-or-value, $n, $default: null) {
    @if (not $list-or-value) {
        @return $default;
    }
    @if (type-of($list-or-value) == 'list') {
        @return nth($list-or-value, $n);
    }
    @return $list-or-value;
}

/// Return a copy of a list with the nth value removed

@function list-remove($list, $n) {
    $result: ();
    $n: if($n < 0, length($list) + $n + 1, $n);
    $bracketed: is-bracketed($list);
    $separator: list-separator($list);
    @for $i from 1 through length($list) {
        @if $i != $n {
            $result: append($result, nth($list, $i));
        }
    }
    @return join((), $result, $separator, $bracketed);
}

/// Returns true if the list contains a value, otherwise false

@function list-contains($list, $val) {
    @return index($list, $val) != null;
}

/// Return a copy of a list sorted numerically

@function list-sort-num($list) {
    $sortedlist: ();
    @while length($list) > 0 {
        $value: nth($list, 1);
        @each $item in $list {
            @if $item < $value {
                $value: $item;
            }
        }
        $sortedlist: append($sortedlist, $value, 'space');
        $list: list-remove($list, index($list, $value));
    }
    @return $sortedlist;
}

/// Return a copy of a list sorted alphabetically

@function list-sort($list) {
    $order: '!' '#' '$' '%' '&' "'" '(' ')' '*' '+' ',' '-' '.' '/' '[' '\\'']' '^' '_' '{' '|' '}' '~''0'
        '1' '2' '3' '4' '5' '6' '7' '8' '9' 'a' 'b' 'c' 'd' 'e' 'f' 'g' 'h' 'i' 'j' 'k' 'l' 'm' 'n'
        'o' 'p' 'q' 'r' 's' 't' 'u' 'v' 'w' 'x' 'y' 'z';

    $less: ();
    $equal: ();
    $large: ();

    @if length($list) > 1 {
        $seed: nth($list, ceil(length($list) / 2));

        @each $item in $list {
            @if ($item == $seed) {
                $equal: append($equal, $item);
            } @else if ($item < $seed) {
                $less: append($less, $item);
            } @else if ($item > $seed) {
                $large: append($large, $item);
            }
        }

        @return join(join(list-sort($less, $order), $equal), list-sort($large, $order));
    }

    @return $list;
}

/// Return a copy of a map sorted by the value of each entry

@function map-sort-by-values($map) {
    $keys: ();
    $values: ();
    $sortedMap: ();

    @each $key, $val in $map {
        $keys: append($keys, $key);
        $values: append($values, $val);
    }

    $list: zip($keys, $values);

    @while length($list) > 0 {
        // find smallest pair
        $smallestPair: nth($list, 1);
        @each $pair in $list {
            $value: nth($pair, 2);
            $smallestValue: nth($smallestPair, 2);
            @if $value < $smallestValue {
                $smallestPair: $pair;
            }
        }

        // add smallest pair to sorted map
        $key: nth($smallestPair, 1);
        $value: nth($smallestPair, 2);
        $sortedMap: map-merge(
            $sortedMap,
            (
                $key: $value
            )
        );

        // remove from list smallest pair
        $smallestPairIndex: index($list, $smallestPair);
        $newList: ();
        @for $i from 1 through length($list) {
            @if $i != $smallestPairIndex {
                $newList: append($newList, nth($list, $i), 'space');
            }
        }
        $list: $newList;
    }

    @return $sortedMap;
}

/// Creates a new list with the results of calling a function once for every
/// item in this list. Equivalent to Array.map in JavaScript.
///
/// @param {List} $list the list to which the function is being applied
///
/// @param {Function} $fn reference to a function(item, index) that will be
/// applied to every item.
///
/// @example
/// @function square($x, $i) { @return $x * $x }
/// list-map(1 2 3 4, square); // => 1 4 9 16
///
@function list-map($list, $fn) {
    @if length($list) == 0 {
        @return ();
    }
    $new-list: $list;
    @for $i from 1 through length($list) {
        $new-list: set-nth($new-list, $i, call($fn, nth($list, $i)));
    }
    @return $new-list;
}

/// Creates a new list with all items that pass the test implemented by the
/// provided function. Similar to Array.filter in JavaScript.
///
/// @param {List} $list the list being filtered
/// @param {Function} $fn reference to a filtering function
///
/// @example
///   @function aboveTen($x) { @return x > 10 }
///   list-filter(2 20 30 3 4 100, aboveTen); // => (20 30 100)

@function list-filter($list, $fn) {
    $new-list: ();
    @each $item in $list {
        @if call($fn, $item) {
            $new-list: append($new-list, $item);
        }
    }
    @return $new-list;
}

/// Merge multiple maps into a single map
/// @param {*} $maps... One or more maps that should be merged into a single map.

@function map-collect($maps...) {
    $collection: ();

    @each $map in $maps {
        $collection: map-merge($collection, $map);
    }
    @return $collection;
}

/// A function that retrieves a "deep" value from a map using path syntax where
/// key names are separated by colons
///
/// @param {map} $map An existing map that serves as the lookup source
///
/// @param {string} $path The path where the value is found, expressed as a list
/// of keys separated by colons (e.g. 'colors:accent')
///
/// @param {*} $fallback [null] An optional fallback value that will be returned
/// in the value isn't found
///
/// @example
/// map-set-path((colors: (red: #F00)), 'colors:red') // -> #F00

@function map-get-path($map, $path, $fallback: null) {
    $keys: str-split($path, ':');
    @each $key in $keys {
        @if (map-has-key($map, $key)) {
            $map: map-get($map, $key);
        } @else {
            @return $fallback;
        }
    }
    @if not $map and $fallback {
        @return $fallback;
    }
    @return $map;
}

/// A function that allows you to set a "deep" value in a map using path syntax
/// where key names are separated by colons
///
/// @param {map} $map An existing map that serves as the basis for the returned
/// value
///
/// @param {string} $path The path where the value should be set, expressed as a
/// list of keys separated by colons (e.g. 'colors:accent')
///
/// @param {*} $val The value to be set at the path
///
/// @returns A new map with the value set (all intermediate objects will be
/// created and values overwritten as needed)
///
/// @example
/// map-set-path((), 'colors:red', #F00) // -> (colors: (red: #F00))
///
/// @example
/// map-set-path((colors: (red: #F00)), 'colors:blue', #00F) // ->
/// {colors: {red: #F00, blue: #00F}}

@function map-set-path($map, $path, $val, $merge-maps: false) {
    $keys: str-split($path, ':');
    $key: nth($keys, 1);
    $next-path: list-join(list-remove($keys, 1), ':');
    $merge: ();

    @if (map-has-key($map, $key)) {
        $existing-value: map-get($map, $key);
        $merge: if(is-map($existing-value), $existing-value, $merge);
    }

    @if (length($keys) > 1) {
        $val: map-set-path($merge, $next-path, $val);
    }

    @if ($merge-maps and is-map($merge) and is-map($val)) {
        $val: map-merge($merge, $val);
    }

    @return map-merge(
        $map,
        (
            $key: $val
        )
    );
}

/// A function that flattens it's "flat" equivalent where every key is replaced
/// with a deep path (see examples) to the original map.
/// @param {map} $map The map to be flattened
///
/// @example
/// flatten-map((colors: (red: #f00, blue: #00f))) => ("colors:red": #f00, "colors:blue": #00f)

@function flatten-map($map) {
    $flat: ();
    @each $key, $value in $map {
        @if (type-of($value) == 'map') {
            $fmap: flatten-map($value);
            @each $fkey, $fvalue in $fmap {
                $flat: map-merge($flat, (#{$key + ':' + $fkey}: $fvalue));
            }
        } @else {
            $flat: map-merge(
                $flat,
                (
                    $key: $value
                )
            );
        }
    }
    @return $flat;
}

/// A function that restores a "flat" map (like one produced by the flatten-map
/// function) to a normal deep map.
//
/// @param {map} $map The map to be unflattened
///
/// @example
/// unflatten-map(("colors:red": #f00, "colors:blue": #00f)) // -> (colors: (red: #f00, blue: #00f))

@function unflatten-map($map) {
    $unflat: ();
    @each $key, $value in $map {
        $unflat: map-set-path($unflat, $key, $value);
    }
    @return $unflat;
}

/// Flatten and then merge two maps. This is not the same as a deep merge
/// because it allows for keys in one (or both) of the maps to be complete
/// paths. Last in list wins.
///
/// @example
/// flatten-map-merge((colors: (red: #f00)), ('colors:blue': #00f))
///     -> (colors: (red: #f00, blue: #00f))
///
/// @example
/// flatten-maps-merge(('clr:main': blue),('clr:main': red));
///     -> (clr: (main: red))

@function flatten-maps-merge($maps...) {
    $flat-maps: ();
    @each $map in $maps {
        @if ($map) {
            $flat-maps: append($flat-maps, flatten-map($map));
        }
    }

    $flat-collection: ();
    @each $map in $flat-maps {
        $flat-collection: map-merge($flat-collection, $map);
    }

    @return unflatten-map($flat-collection);
}
